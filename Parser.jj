PARSER_BEGIN(Parser)

import java.io.*;
import java.util.*;

/** ID lister. */
public class Parser {

  /** Main entry point. */
  public static void main(String args[]) throws IOException, ParseException, TypeError {
    CodeBlock c;
    if (args.length > 0){
      c = new CodeBlock();
      Parser parser = new Parser(new FileInputStream(args[0]));
      ASTNode exp = parser.Start();
      exp.compile(c);
      FileWriter writer = new FileWriter(new File("ctmp"), false);
      writer.write(c.print());
      writer.close();
    }
    else {
      Parser parser = new Parser(System.in);
      ASTNode exp;
      while (true) {
        try {
          exp = parser.Start();
          System.out.println("-> "+exp.eval(new Env()));
        }
        catch (Env.UndeclaredIdentifier e) {
          System.out.println ("Undeclared id.");
          parser.ReInit(System.in);
        }
        catch (Env.IdentifierDeclaredTwice e) {
          System.out.println ("Id declared twice.");
          parser.ReInit(System.in);
        }
        catch (TypeError e) {
          System.out.println ("Unexpected operand type.!");
          parser.ReInit(System.in);
        }
        catch (ParseException e) {
          System.out.println ("Syntax error.");
          parser.ReInit(System.in);
        }
      }
    }
  }
}

PARSER_END(Parser)

SKIP :
{
  " "
  | "\t"
  | "\n"
}

TOKEN :
{
  < DECL:    "decl" >
  | < WHILE: "while">
  | < FUN:   "fun"  >
  | < DO:    "do"   >
  | < NEW:   "new"  >
  | < IN:    "in"   >
  | < END:   "end"  >
  | < TRUE:  "true" >
  | < FALSE: "false">
  | < IF:    "if"   >
  | < THEN:  "then" >
  | < ELSE:  "else" >
  | < PRNT:  "print">
  | < PRNTLN:"println">
  | < ID:    ["a"-"z","A"-"Z"] (["a"-"z","A"-"Z","0"-"9"])* >
  | < NUM:   (["0"-"9"])+ >
  | < SEMI : ";"    >
  | < COMM : ","    >
  | < PLUS : "+"    >
  | < MINUS: "-"    >
  | < TIMES: "*"    >
  | < DIV:   "/"    >
  | < LPAR:  "("    >
  | < RPAR:  ")"    >
  | < OR:    "||"   >
  | < AND:   "&&"   >
  | < COL:   ":"    >
  | < EQ:    "="    >
  | < GT:    ">"    >
  | < GET:   ">="   >
  | < LT:    "<"    >
  | < LET:   "<="   >
  | < IFC:   "?"    >
  | < DEREF: "!"    >
  | < NOT:   "~"    >
  | < NOTE:  "!="   >
  | < EL:    ";;\n" >
}

ASTNode Prog():
{
  ASTNode t;
}
{
  t = SExp() <EL>
  {
    return t;
  }
}

ASTNode SExp():
{
  ASTNode t1, t2;
}
{
  t1 = LAss() (<SEMI> t2 = LAss()
  {
    t1 = new ASTMultiple(t1, t2);
  })*
  {
    return t1;
  }
}

ASTNode LAss():
{
  ASTNode t1, t2;
}
{
  t1 = LExp() (<COL><EQ> t2 = LExp()
  {
    t1 = new ASTAssi(t1, t2);
  })?
  {
    return t1;
  }
}

ASTNode LExp():
{
  ASTNode t1, t2;
}
{
  t1 = LTerm() (<OR> t2 = LTerm()
  {
    t1 = new ASTOr(t1, t2);
  })*
  {
    return t1;
  }
}

ASTNode LTerm():
{
  ASTNode t1, t2;
}
{
  t1 = LFact() (<AND> t2 = LFact()
  {
    t1 = new ASTAnd(t1, t2);
  })*
  {
    return t1;
  }
}

ASTNode LFact():
{
  ASTNode t1, t2;
}
{
  t1 = LCmp() | <NOT> t1 = LFact()
  {
    t1 = new ASTNot(t1);
  }
  {
    return t1;
  }
}

ASTNode LCmp():
{
  Token op;
  ASTNode t1, t2;
}
{
  t1 = Exp() ( (op = <EQ><EQ> | op = <NOTE> | op = <GT> | op = <GET> | op = <LT> | op = <LET> ) t2 = Exp()
  {
    if (op.kind == EQ )
      t1 = new ASTEquals(t1, t2);
    else if (op.kind == NOTE )
      t1 = new ASTNotEquals(t1, t2);
    else if (op.kind == GT )
      t1 = new ASTGthen(t1, t2);
    else if (op.kind == GET )
      t1 = new ASTGEthen(t1, t2);
    else if (op.kind == LT )
      t1 = new ASTLthen(t1, t2);
    else
      t1 = new ASTLEthen(t1, t2);
  })?
  {
    return t1;
  }
}

ASTNode Exp():
{
  Token op;
  ASTNode t1, t2;
}
{
  t1 = Term() ( ( op = <PLUS> | op = <MINUS> ) t2 = Term()
  {
    if (op.kind == PLUS)
      t1 = new ASTPlus(t1, t2);
    else
      t1 = new ASTSub(t1, t2);
  })*
  {
    return t1;
  }
}

ASTNode Term():
{
  Token op;
  ASTNode t1, t2;
}
{
  t1 = Fact() ( ( op = <TIMES> | op = <DIV> ) t2 = Fact()
  {
    if (op.kind == TIMES)
      t1 = new ASTMul(t1, t2);
    else
      t1 = new ASTDiv(t1, t2);
   })*
  {
    return t1;
  }
}

ASTNode Fact() :
{
  Token n=null;
  ASTNode t1, t2, t3;
  Vector<Binding> ve;
  Vector<String> vs;
}
{
  ( <MINUS> n = <NUM> { t1 = new ASTNeg(Integer.parserInt(n.image)); }
  | <DEREF> t1 = Fact() { t1 = new ASTDeref(t1); }
  | SFact() (CFact())?
  | <WHILE> t1 = SExp() <DO> t2 = SExp() <END> { t1 = new ASTWhile(t1, t2); }
  | <IF> t1 = SExp() <THEN> t2 = SExp() <ELSE> t3 = SExp() { t1 = new ASTIf(t1, t2, t3); }
  //-----------------
  (n=<NUM> {t= new ASTNum(Integer.parseInt(n.image)); }
  | n=<ID> {t= new ASTId(n.image); }
  | <DECL>   { ve = new Vector<Binding>(); }
             ( n=<ID> <EQ> t=EMu()
             { ve.addElement(new Binding(n.image, t)); }
             )+
    <IN> e=EMu() <END> { t = new ASTDecl(ve,e); }
  | <LPAR> t=EMu() <RPAR>
  | (n=<TRUE>|n=<FALSE>) {t = new ASTBool(n.image); }
  | <MINUS> n=<NUM> { t= new ASTNeg(Integer.parseInt(n.image)); }
  | <FUN> {vs = new Vector<String>();}
          (
            (n=<ID>{vs.addElement(n.image);})
            (<COMM>n=<ID>{vs.addElement(n.image);})*
          )?
          <EQ><GT> e=EMu() <END> {t = new ASTFun(vs, e);})
  {return t;}
}

ASTNode SFact():
{
}

ASTNode CFact():
{
}

//------------ APAGAR O RESTO ------------//

ASTNode Ecard():
{
  Token op;
  ASTNode t1, t2, t3;
}
{
  <IF> t1=Exp() <THEN> t2=Exp() <ELSE> t3=Exp() { return new ASTIf(t1,t2,t3); }
  | <WHILE> <LPAR>t1=ELog()<RPAR> <DO> t2=EMu() <END> { return new ASTWhile(t1,t2); }
  | t1 = Exp() {return t1;}
}



ASTNode Print():
{
 Token op=null;
 ASTNode t;
}
{
  (op=<PRNTLN> | op=<PRNT>)? t=Deref() {if (op!=null)t = new ASTPrintln(t);}
  {
    return t;
  }
}

ASTNode Deref():
{
  Token op = null;
  ASTNode t1;
}
{
  (op=<DEREF>)? t1=Eref()
  {
    if (op!=null)
        t1= new ASTDeref(t1);
  }
  {
    return t1;
  }
}

ASTNode Eref():
{
  Token op = null;
  ASTNode t1;
}
{
  (op=<NEW> | op=<NOT>)? t1=Call()
  {
    if (op!=null)
      if(op.kind == NEW)
        t1= new ASTNew(t1);
      else if(op.kind==NOT)
        t1= new ASTNot(t1);
  }
  {
    return t1;
  }
}

ASTNode Call():
{
  ASTNode t, n;
  Vector<ASTNode> v;
}
{
  t = Fact() (<LPAR>{ v = new Vector<ASTNode>(); }
    (
      (n=Fact() {v.addElement(n);})
      (<COMM>n=Fact() {v.addElement(n);})*
    )?
    <RPAR>
  {
    t = new ASTCall(v,t);
  })?
  {
    return t;
  }
}


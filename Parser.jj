PARSER_BEGIN(Parser)

import java.io.*;
import java.util.*;

/** ID lister. */
public class Parser {

  /** Main entry point. */
  public static void main(String args[]) throws IOException, ParseException, TypeError {
    CodeBlock c;
    if (args.length > 0){
      c = new CodeBlock();
      Parser parser = new Parser(new FileInputStream(args[0]));
      ASTNode exp = parser.Start();
      exp.compile(c);
      FileWriter writer = new FileWriter(new File("ctmp"), false);
      writer.write(c.print());
      writer.close();
    }
    else {
      Parser parser = new Parser(System.in);
      ASTNode exp;
      while (true) {
        try {
          exp = parser.Start();
          System.out.println("-> "+exp.eval(new Env()));
        }
        catch (Env.UndeclaredIdentifier e) {
          System.out.println ("Undeclared id.");
          parser.ReInit(System.in);
        }
        catch (Env.IdentifierDeclaredTwice e) {
          System.out.println ("Id declared twice.");
          parser.ReInit(System.in);
        }
        catch (TypeError e) {
          System.out.println ("Unexpected operand type.!");
          parser.ReInit(System.in);
        }
        catch (ParseException e) {
          System.out.println ("Syntax error.");
          parser.ReInit(System.in);
        }
      }
    }
  }
}

PARSER_END(Parser)

SKIP :
{
  " "
  | "\t"
  | "\n"
}

TOKEN :
{
  < DECL:    "decl" >
  | < WHILE: "while">
  | < DO:    "do"   >
  | < NEW:   "new"  >
  | < IN:    "in"   >
  | < END:   "end"  >
  | < TRUE:  "true" >
  | < FALSE: "false">
  | < IF:    "if"   >
  | < THEN:  "then" >
  | < ELSE:  "else" >
  | < PRNT:  "print">
  | < PRNTLN:"println">
  | < ID:    ["a"-"z","A"-"Z"] (["a"-"z","A"-"Z","0"-"9"])* >
  | < NUM:   (["0"-"9"])+ >
  | < SEMI : ";"    >
  | < PLUS : "+"    >
  | < MINUS: "-"    >
  | < TIMES: "*"    >
  | < DIV:   "/"    >
  | < LPAR:  "("    >
  | < RPAR:  ")"    >
  | < OR:    "||"   >
  | < AND:   "&&"   >
  | < COL:   ":"    >
  | < EQ:    "="    >
  | < GT:    ">"    >
  | < GET:   ">="   >
  | < LT:    "<"    >
  | < LET:   "<="   >
  | < IFC:   "?"    >
  | < DEREF: "!"    >
  | < NOT:   "~"    >
  | < NOTE:  "!="   >
  | < EL:    ";;\n" >
}

ASTNode Start():
{
  ASTNode t;
}
{
  t = EMu() <EL>
  {
    return t;
  }
}

ASTNode EMu():
{
  ASTNode t1, t2;
}
{
  t1 = Assi() ( <SEMI> t2 = Assi()
  {
    t1 = new ASTMultiple(t1,t2);
  })*
  {
    return t1;
  }
}

ASTNode Assi():
{
  ASTNode t1, t2;
}
{
  t1=ELog() (<COL><EQ> t2=ELog()
  {
    t1 = new ASTAssi(t1, t2);
  })*
  {
    return t1;
  }
}

ASTNode ELog():
{
  ASTNode t1, t2;
}
{
  t1 = TLog() ( <AND> t2 = TLog()
  {
    t1 = new ASTAnd(t1, t2);
  })*
  {
    return t1;
  }
}

ASTNode TLog():
{
  ASTNode t1, t2;
}
{
  t1 = Ecmp() ( <OR> t2 = Ecmp()
  {
    t1 = new ASTOr(t1, t2);
  })*
  {
    return t1;
  }
}



ASTNode Ecmp():
{
  Token op;
  ASTNode t1, t2;
}
{
  t1 = Ecard() ( (op = <EQ><EQ> | op = <NOTE> | op = <GT> | op = <GET> | op = <LT> | op = <LET> ) t2 = Ecard()
  {
    if (op.kind == EQ )
      t1 = new ASTEquals(t1,t2);
    else if (op.kind == NOTE )
      t1 = new ASTNotEquals(t1,t2);
    else if (op.kind == GT )
      t1 = new ASTGthen(t1,t2);
    else if (op.kind == GET )
      t1 = new ASTGEthen(t1,t2);
    else if (op.kind == LT )
      t1 = new ASTLthen(t1,t2);
    else
      t1 = new ASTLEthen(t1,t2);
  })?
  {
    return t1;
  }
}

ASTNode Ecard():
{
  Token op;
  ASTNode t1, t2, t3;
}
{
  <IF> t1=Exp() <THEN> t2=Exp() <ELSE> t3=Exp() { return new ASTIf(t1,t2,t3); }
  | <WHILE> <LPAR>t1=ELog()<RPAR> <DO> t2=EMu() <END> { return new ASTWhile(t1,t2); }
  | t1 = Exp() {return t1;}
}

ASTNode Exp():
{
  Token op;
  ASTNode t1, t2;
}
{
  t1 = Term() ( ( op = <PLUS> | op = <MINUS> ) t2 = Term()
  {
    if (op.kind == PLUS)
      t1 = new ASTPlus(t1,t2);
    else
      t1 = new ASTSub(t1,t2);
  })*
  {
    return t1;
  }
}

ASTNode Term():
{
  Token op;
  ASTNode t1, t2;
}
{
  t1 = Print() ( ( op = <TIMES> | op = <DIV> ) t2 = Print()
  {
    if (op.kind == TIMES)
      t1 = new ASTMul(t1,t2);
    else
      t1 = new ASTDiv(t1,t2);
   })*
  {
    return t1;
  }
}



ASTNode Print():
{
 Token op=null;
 ASTNode t;
}
{
  (op=<PRNTLN> | op=<PRNT>)? t=Deref() {if (op!=null)t = new ASTPrintln(t);}
  {
    return t;
  }
}

ASTNode Deref():
{
  Token op = null;
  ASTNode t1;
}
{
  (op=<DEREF>)? t1=Eref()
  {
    if (op!=null)
        t1= new ASTDeref(t1);
  }
  {
    return t1;
  }
}

ASTNode Eref():
{
  Token op = null;
  ASTNode t1;
}
{
  (op=<NEW> | op=<NOT>)? t1=Fact()
  {
    if (op!=null)
      if(op.kind == NEW)
        t1= new ASTNew(t1);
      else if(op.kind==NOT)
        t1= new ASTNot(t1);
  }
  {
    return t1;
  }
}

ASTNode Fact() :
{
  Token n=null;
  ASTNode t, e;
  Vector<Binding> ve;
}
{
  (n=<NUM> {t= new ASTNum(Integer.parseInt(n.image)); }
  | n=<ID> {t= new ASTId(n.image); }
  | <DECL>   { ve = new Vector<Binding>(); }
             ( n=<ID> <EQ> t=EMu()
             { ve.addElement(new Binding(n.image, t)); }
             )+
    <IN> e=EMu() <END> { t = new ASTDecl(ve,e); }
  | <LPAR> t=EMu() <RPAR>
  | (n=<TRUE>|n=<FALSE>) {t = new ASTBool(n.image); }
  | <MINUS> n=<NUM> { t= new ASTNeg(Integer.parseInt(n.image)); })
  {return t;}
}
